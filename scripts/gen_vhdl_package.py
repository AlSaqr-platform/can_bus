import argparse
import sys
import time
import importlib.util
import os
import inspect

# File path to the local repo of the PyXact framework
PYXACT_PATH = "E:\Skola\CVUT-FEL\ipyxact"
sys.path.insert(0, PYXACT_PATH)

from ipyxact.ipyxact import Component

def parse_args():
    parser = argparse.ArgumentParser(
            description='Generate a C header from an IP-XACT file')
    parser.add_argument('ipxact_file', help='IP-XACT file to parse')
    parser.add_argument('-o', dest='output_file', help='Write output to file')
    parser.add_argument('-g', '--header-guard', dest='header_guard',
            help='Header guard. If not specified it will be derived from the '
                 'output file name else there will be no guard.')
    return parser.parse_args();

def open_output(output):
    return open(output, 'w') if output else sys.stdout

def split_string(input, size):
	return [input[start:start+size] for start in range(0, len(input), size)]

def write_comment(of, input, prefix):
	splt_str = split_string(input, 75)
	for line in splt_str:
		of.write('{}-- {}\n'.format(prefix, line))







def write_prologue(of, packageName, comment):
	comLine = '{:{fill}<80}\n'.format("", fill="-",)
	purp = '-- Purpose:\n'
	of.write(comLine + purp)
	write_comment(of, comment, "")
	of.write(comLine+'\n')
	of.write('Library ieee;\nuse ieee.std_logic_1164.all;\n\n')
	of.write('package {} is\n\n'.format(packageName))

def write_epilogue(of):
	of.write('end package;')



def write_reg_elem(of, elem, reg, type, busWidth):
	#Calculate the bit index in the data word based on bus width that
	#is used to acccess the register
	bitIndexL = elem.bitOffset
	bitIndexH = elem.bitOffset + elem.bitWidth-1
	bitIndexL = bitIndexL + ((reg.addressOffset*8) % busWidth)
	bitIndexH = bitIndexH + ((reg.addressOffset*8) % busWidth)
			
	if (bitIndexH == bitIndexL):
		iter = [["IND", bitIndexL]]
	else:
		iter = [["L", bitIndexL], ["H", bitIndexH]]
			
	for item in iter:
		pref = '  constant {}_{} '.format(elem.name.upper(), item[0])
		post = ': {} := {};\n'.format(type, item[1])
		post = '{:>{}}'.format(post, 50-len(pref))
		of.write(pref + post)

def write_reg_bits(of, registers, type, busWidth):
	for reg in registers:
		
		#Write the register title
		comLine = '{:{fill}<80}\n'.format("  ", fill="-",)
		of.write(comLine)
		of.write('  -- {} register\n'.format(reg.name.upper()))
		of.write('  --\n')
		write_comment(of, reg.description, "  ")
		of.write(comLine)
		
		#Write the individual elements
		for elem in reg.field:
			write_reg_elem(of, elem, reg, type, busWidth)
				
		of.write('\n')

def write_memory_map_fields(of, memoryMap, busWidth):
	for block in memoryMap.addressBlock:
		write_reg_bits(of, block.register, "natural", busWidth)
	
	



def write_address_block_head(of, addressBlock, vhdlType, vhdlLen):
	
	# Write capital comment with name of the address Block
	comLine = '{:{fill}<78}\n'.format("  ", fill="-",)
	com = '  -- Address block: {}\n'.format(addressBlock.name)
	of.write(comLine+com+comLine)
	
	# Write the VHDL constant for Address block offset defined as:
	#	block.baseAddress/block.range
	pref = '  constant {}_BLOCK'.format(addressBlock.name.upper())
	post = ': {}({} downto 0) := x"{}";\n'.format(vhdlType, 3, 
				int(addressBlock.baseAddress/addressBlock.range))
	pref_len = 80-len(pref)
	# Right align to 80 chars
	post = '{:>{}}'.format(post, pref_len)
	of.write(pref+post+"\n")

def write_address_block_regs(of, addressBlock, vhdlType, vhdlLen):
	
	for reg in sorted(addressBlock.register, key=lambda a: a.addressOffset):
		pref = '  constant {}_ADR '.format(reg.name.upper())
		addr = '{:03X}'.format(reg.addressOffset,fill='0')
		post = ': {}({} downto 0) := x"{}";\n'.format(vhdlType, vhdlLen, addr)
		pref_len = 80-len(pref)
		post = '{:>{}}'.format(post, pref_len)
		of.write(pref+post)
	of.write('\n\n');
		
		
def write_memory_map_addr(of, memoryMap, vhdlType):
	#Each Address block reflects to VHDL memory region
	for block in memoryMap.addressBlock:
		write_address_block_head(of, block, "std_logic_vector", 3)
		write_address_block_regs(of, block, "std_logic_vector", 11)
		


	
if __name__ == '__main__':
	args = parse_args()
	with open(args.ipxact_file) as f:
		name = None
		offset = 0
        
		component = Component()
		component.load(f)
		
		with open_output(args.output_file) as of:
			
			packageName = 'CAN_FD_register_map'
			comment = 'Package with Address constants for CAN FD register map.'
			comment = comment + 'This file is autogenerated, do NOT EDIT!'
			write_prologue(of, packageName, comment)
				
			for map in component.memoryMaps.memoryMap:
				if map.name == "CAN_FD_32bit_regs":
					write_memory_map_addr(of, map, "std_logic_vector")
				if map.name == "CAN_FD_8bit_regs":
					write_memory_map_fields(of, map, 32)
				
			write_epilogue(of)